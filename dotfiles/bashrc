# ENVIRONMENT
#

export EDITOR=nvim
export FZF_DEFAULT_OPTS="--tiebreak=index --no-mouse --no-bold \
    --layout=reverse --preview-window=down,border-top --margin 0,1 \
    --color 16,prompt:2,hl:2,hl+:2,fg+:3,pointer:3 \
    --bind shift-left:preview-page-up,shift-right:preview-page-down"
export FZF_TMUX=1
export LESS="--raw-control-chars --chop-long-lines --no-init"
export PATH="${HOME}/bin:${HOME}/go/bin:${PATH}"
export PROJECTS_DIR=~/Projects
export PROJECT_HOME="${PROJECTS_DIR}"
export RIPGREP_CONFIG_PATH=~/.ripgreprc
export SSH_AUTH_SOCK="${XDG_RUNTIME_DIR}/.ssh-agent.sock"

# GENERAL
#

# Define PROMPT_COMMAND as an array so following sections can add their own commands
PROMPT_COMMAND=()

# Set tmux title to simply "bash"
tmux_title() {
    echo -ne "\033]0;\a"
}
PROMPT_COMMAND+=("tmux_title")

# Prevent Ctrl-S from freezing the terminal
stty -ixon

# DEPENDENCIES
#

# Source standard completions
source /usr/share/bash-completion/bash_completion

# FZF keybindings: cd with Alt-C, insert file path with Ctrl-T
source /usr/share/doc/fzf/examples/key-bindings.bash

# Virtualenvwrapper
source /usr/share/virtualenvwrapper/virtualenvwrapper.sh

# HISTORY
#

# Huge history
HISTSIZE=100000
HISTFILESIZE=100000

# Append to history file instead of overwriting it
shopt -s histappend

# Save multi line commands literally, with newlines as entered
shopt -s lithist

# Write history before each priting of the prompt
PROMPT_COMMAND+=("history -a")

# PROMPT
#

# Color definitions
# Bash will garble output if these are not surrounded by []
RED="\[$(tput setaf 1)\]"
GREEN="\[$(tput setaf 2)\]"
YELLOW="\[$(tput setaf 3)\]"
BLUE="\[$(tput setaf 4)\]"
PURPLE="\[$(tput setaf 5)\]"
LIGHT_GRAY="\[$(tput setaf 8)\]"
RESET="\[$(tput setaf 15)\]"

# Set git-related variables for prompt
__update_git_status() {
    GIT_REPO=$(git rev-parse --git-dir 2>&1 >/dev/null && echo true || echo false)

    if [ "${GIT_REPO}" = true ]; then
        GIT_PS1_STAGED=0
        GIT_PS1_NONSTAGED=0
        GIT_PS1_UNTRACKED=0

        declare -a fields
        while IFS=$' ' read -a fields; do
            case "${fields[0]}" in
                "#")
                    case "${fields[1]}" in
                        "branch.head")
                            GIT_PS1_BRANCH="${fields[2]}"
                            ;;
                        "branch.oid")
                            GIT_PS1_COMMIT="${fields[2]}"
                            ;;
                    esac
                    ;;
                "1")
                    if [ "${fields[1]:0:1}" != "." ]; then
                        ((GIT_PS1_STAGED++))
                    fi
                    if [ "${fields[1]:1:1}" != "." ]; then
                        ((GIT_PS1_NONSTAGED++))
                    fi
                    ;;
                "?")
                    ((GIT_PS1_UNTRACKED++))
                    ;;
            esac
        done < <(git status --branch --porcelain=v2)
    fi
}

# Update git status before displaying the prompt
PROMPT_COMMAND+=("__update_git_status")

# Print the git branch part of the prompt
__ps1_git_branch() {
    if [ "${GIT_REPO}" = true ]; then
        if [ "${GIT_PS1_BRANCH}" = "(detached)" ]; then
            echo "${GIT_PS1_COMMIT:0:8} "
        else
            echo "${GIT_PS1_BRANCH} "
        fi
    fi
}

# Print the git status part of the prompt
__ps1_git_status() {
    if [ "${GIT_REPO}" = true ]; then
        local status=""
        status+=$([ "${GIT_PS1_STAGED}" -gt 0 ] && echo "+" || echo "")
        status+=$([ "${GIT_PS1_NONSTAGED}" -gt 0 ] && echo "*" || echo "")
        status+=$([ "${GIT_PS1_UNTRACKED}" -gt 0 ] && echo "?" || echo "")
        echo "${status}"
    fi
}

# Virtualenv
__ps1_virtualenv() {
    [[ "${VIRTUAL_ENV}" == "" ]] && echo "" || echo "${BLUE}venv${RESET} "
}

# Set final prompt
__set_ps1() {
    local status=$?
    local prompt
    if [ "${status}" -eq 0 ]; then
        prompt="${GREEN}>${RESET}"
    else
        prompt="${RED}>${RESET}"
    fi
    export PS1="${YELLOW}\w $(__ps1_virtualenv)${PURPLE}$(__ps1_git_branch)${LIGHT_GRAY}$(__ps1_git_status) 
${prompt} "
}
PROMPT_COMMAND+=("__set_ps1")

# ALIASES
#

# cal with more readable output
cal() {
    ncal -M -b "$@"
}

# ls with more readable output
ls() {
    command ls \
        --color=auto \
        --group-directories-first \
        --literal \
        --time-style=long-iso \
        --human-readable \
        "$@"
}

# diff with colors and pager, unless running in a pipeline
diff() {
    if [[ -t 1 ]]; then
        command diff --color=always "$@" | less -FRS
    else
        command diff "$@"
    fi
}

# rg with colors and pager, unless running in a pipeline
rg() {
    if [[ -t 1 ]]; then
        command rg --color=always --line-number "$@" | less -FRS
    else
        command rg "$@"
    fi
}

# COMPLETION FUNCTIONS
#

# Complete directory paths using prefix or infix completion of the last path
# component
__complete_directory_path() {
    # Input string to complete
    local input="$1"

    # Root directory under which to look for matching directory path,
    # used only if input is a relative path
    local relative_root="$2"

    # Expand ~ in input if present
    if [[ "${input}" =~ ^~ ]]; then
        input="${HOME}/${input#"~/"}"
    fi

    # Part of input until and including the last /
    # it should consitute an already complete valid path,
    # otherwise we should not attempt completion
    local complete_path

    # Part of input after last /
    # this is the part that we actually try to complete
    local incomplete_path

    # Split input string into complete and incomplete part
    if [[ "${input}" =~ / ]]; then
        complete_path="${input%/*}/"
        incomplete_path="${input##*/}"
    else
        complete_path=""
        incomplete_path="${input}"
    fi

    # Argument list for find
    declare -a find_args

    # Determine the directory in which to look for completion candidates
    if [[ "${complete_path}" =~ ^/ ]]; then
        # Case of absolute path
        find_args+=("${complete_path}")
    else
        # Case of relative path
        find_args+=("${relative_root}/${complete_path}")
    fi

    # Look for immediate subdirectories
    find_args+=(-mindepth 1 -maxdepth 1 -type d)

    # Look for the substring in directory name
    find_args+=(-name "*${incomplete_path}*")

    # Ignore hidden directories unless the substring to search for starts with .
    if [[ ! "${incomplete_path}" =~ ^\. ]]; then
        find_args+=(-not -name ".*")
    fi

    # Print only names of matching directories
    find_args+=(-printf "%P\n")

    # Read and postprocess the completion candidates
    declare -a prefix_matches
    declare -a infix_matches
    while IFS= read -r match; do
        if [[ "${match}" =~ ^${incomplete_path} ]]; then
            prefix_matches+=("${complete_path}${match}/")
        else
            infix_matches+=("${complete_path}${match}/")
        fi
    done < <(find "${find_args[@]}" | LC_ALL=C sort)

    # Completion candidates consists of prefix matches followed by infix matches
    COMPREPLY=("${prefix_matches[@]}" "${infix_matches[@]}")
}

__complete_cd_infix() {
    __complete_directory_path "${COMP_WORDS[-1]}" "."
}

complete -F __complete_cd_infix -o nospace -o nosort cd

# FUNCTIONS
#

# open notes
nt() {
    $EDITOR ~/Notes/notes.md
}

# FUNCTIONS - PROJECTS
#

# cd to project
cdp() {
    local project_name="${1%%/*}"
    local project_relative_path="${1#*/}"

    local project_root="${PROJECTS_DIR}/${project_name}"

    if [ -d "${project_root}" ]; then
        local destination_path="${project_root}/${project_relative_path}"
        if [ -d "${destination_path}" ]; then
            __activate_venv "${project_name}"
            cd "${destination_path}"
        else
            printf "Destination '%s' in project '%s' does not exist\n" "${project_relative_path}" "${project_name}"
        fi
    else
        printf "Project '%s' does not exist\n" "${project_name}"
    fi
}

__activate_venv() {
    local project_name="$1"

    while IFS= read virtualenv; do
        if [[ "${virtualenv}" == "${project_name}" ]]; then
            workon "${virtualenv}"
        fi
    done < <(lsvirtualenv -b)
}

__complete_cdp() {
    __complete_directory_path "${COMP_WORDS[-1]}" "${PROJECTS_DIR}"
}

complete -F __complete_cdp -o nospace -o nosort cdp

# cd to project root
cdpr() {
    local cwd=$(pwd)
    if [[ "${cwd}" =~ ^${PROJECTS_DIR}/.+$ ]]; then
        local project=$(echo "${cwd}" | cut -c "$((${#PROJECTS_DIR}+1))-" | cut -d/ -f2)
        cd "${PROJECTS_DIR}/${project}"
    else
        echo "Not in a project"
    fi
}

# FUNCTIONS - DIRECTORY TREES
#

# directory tree - with pager, unless running in a pipeline

t() {
    if [[ -t 1 ]]; then
        command rl "$@" | less -FRS
    else
        command rl "$@"
    fi
}

complete -F __complete_cd_infix -o nospace -o nosort t

# directory tree - edit in vim

vt() {
    command rl "$@" | $EDITOR \
        -c ":lua require('filelist').load()" \
        -c ":bdelete!"
}

complete -F __complete_cd_infix -o nospace -o nosort vt

# FUNCTIONS - GIT
#

# git log browser
lg() {
    declare -a args
    declare -a paths

    while [ $# -gt 0 ]; do
        if [ "$1" == "--" ]; then
            shift
            while [ $# -gt 0 ]; do
                paths+=("$1")
                shift
            done
        else
            args+=("$1")
            shift
        fi
    done

    if [ ${#paths[@]} -eq 0 ]; then
        paths=(".")
    fi

    local paths_expanded=$(printf "%q " "${paths[@]}")

    git lg --color=always "${args[@]}" -- "${paths[@]}" | \
        fzf \
        --ansi \
        --preview="git show --color=always {1} -- ${paths_expanded}" \
        --bind="ctrl-m:execute:(git show --color=always {1} -- ${paths_expanded} | less -CRX)"
}

