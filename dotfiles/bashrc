# GENERAL
#

# Define PROMPT_COMMAND as an array so following sections can add their own commands
PROMPT_COMMAND=()

# Source standard completions
source /usr/share/bash-completion/bash_completion

# FZF keybindings: cd with Alt-C, insert file path with Ctrl-T
source /usr/share/doc/fzf/examples/key-bindings.bash

# ENVIRONMENT
#

export EDITOR=nvim
export FZF_DEFAULT_OPTS="--layout=reverse --preview-window=down --no-mouse --no-bold \
    --bind shift-left:preview-page-up,shift-right:preview-page-down \
    --color 16,fg+:11,hl+:9,hl:9,pointer:9"
export FZF_TMUX=1
export LESS="--raw-control-chars --chop-long-lines --no-init"
export PATH="${HOME}/bin:${PATH}"
export PROJECTS_DIR=~/Projects
export RIPGREP_CONFIG_PATH=~/.ripgreprc
export SSH_AUTH_SOCK="${XDG_RUNTIME_DIR}/.ssh-agent.sock"

# HISTORY
#

# Huge history
HISTSIZE=100000
HISTFILESIZE=100000

# Append to history file instead of overwriting it
shopt -s histappend

# Save multi line commands literally, with newlines as entered
shopt -s lithist

# Write history before each priting of the prompt
PROMPT_COMMAND+=("history -a")

# PROMPT
#

# Parse git status output if in a git repo and set variables for prompt
__update_git_status() {
    GIT_STATUS=$(git status --branch --porcelain=v2 2>/dev/null)
    GIT_REPO=$([ $? -eq 0 ] && echo "true" || echo "false")

    if [ "${GIT_REPO}" = true ]; then
        IFS=$'\t' read GIT_PS1_BRANCH GIT_PS1_STAGED GIT_PS1_NONSTAGED GIT_PS1_UNTRACKED < \
            <(echo "${GIT_STATUS}" | awk -f ~/bin/git-status-summary.awk)
    fi
}

# Update git status before displaying the prompt
PROMPT_COMMAND+=("__update_git_status")

# Print the git branch part of the prompt
__ps1_git_branch() {
    if [ "${GIT_REPO}" = true ]; then
        echo ${GIT_PS1_BRANCH}
    fi
}

# Print the git status part of the prompt
__ps1_git_status() {
    if [ "${GIT_REPO}" = true ]; then
        local status=""
        status+=$([ ${GIT_PS1_STAGED} -gt 0 ] && echo "+" || echo "")
        status+=$([ ${GIT_PS1_NONSTAGED} -gt 0 ] && echo "*" || echo "")
        status+=$([ ${GIT_PS1_UNTRACKED} -gt 0 ] && echo "?" || echo "")
        echo "${status}"
    fi
}

# Color definitions
BRIGHT_YELLOW="\[$(tput setaf 11)\]"
BRIGHT_BLUE="\[$(tput setaf 12)\]"
BRIGHT_PURPLE="\[$(tput setaf 13)\]"
GRAY="\[$(tput setaf 7)\]"
RESET="\[$(tput sgr0)\]"

# Prompt definition
PS1="${BRIGHT_YELLOW}\w ${BRIGHT_PURPLE}\$(__ps1_git_branch)\$(__ps1_git_status)
${BRIGHT_BLUE}> ${RESET}"

# FUNCTIONS - ALIASES
#

# cal with more readable output
cal() {
    ncal -M -b
}

# ls with more readable output
ls() {
    /usr/bin/ls --color=auto --group-directories-first --literal --time-style=long-iso --human-readable
}

# diff with colors and pager, unless running in a pipeline
diff() {
    if [[ -t 1 ]]; then
        /usr/bin/diff --color=always $@ | less -FRS
    else
        /usr/bin/diff $@
    fi
}

# rg with colors and pager, unless running in a pipeline
rg() {
    if [[ -t 1 ]]; then
        /usr/bin/rg --color=always --line-number $@ | less -FRS
    else
        /usr/bin/rg $@
    fi
}

# FUNCTIONS - NOTES
#

nt() {
    $EDITOR ~/Notes/notes.md
}

# FUNCTIONS - PROJECTS
#

# cd to project
cdp() {
    local project_dir="${PROJECTS_DIR}/$1"
    if [ -d "${project_dir}" ]; then
        cd "${project_dir}"
    else
        echo "Project does not exist"
    fi
}

# current project root
cpr() {
    local cwd=$(pwd)
    if [[ "${cwd}" =~ ^${PROJECTS_DIR}/.*$ ]]; then
        pwd | cut -c "$((${#PROJECTS_DIR}+1))-" | cut -d/ -f2
    fi
}

_cdp() {
    if [ ${#COMP_WORDS[@]} -gt 2 ]; then
        return
    fi

    local query=${COMP_WORDS[1]}

    if [[ ! "${query}" =~ / ]]; then
        # Find matching project names
        IFS=$'\n' read -d '' -r -a COMPREPLY < \
            <(__cdp_find_subdirs "${PROJECTS_DIR}" "${query}*" -printf "%P\n")
    else
        # The completed part of the user input - until last slash
        local complete_dirname=$(echo "${query}" | sed -E 's/(.*)\/.*/\1/')
        
        # The part of the user input to complete - after last slash
        local partial_dirname=$(echo "${query}" | sed -E 's/.*\/(.*)/\1/')

        # Starting point for find
        local root="${PROJECTS_DIR}/${complete_dirname}"

        # Find matching project subdirectories
        IFS=$'\n' read -d '' -r -a COMPREPLY < \
            <(__cdp_find_subdirs "${root}" "${partial_dirname}*" -printf "${complete_dirname}/%P\n")
    fi
}

__cdp_find_subdirs() {
    # "dir" is lexicographically before "dir-xyz", but "dir/" is lexicographically after "dir-xyz/",
    # so sort first and only then add the trailing slash
    find "$1" -mindepth 1 -maxdepth 1 -not -path '*/.*' -type d -name "$2" ${@:3} | \
        LC_ALL=C sort | sed 's/$/\//'
}

complete -F _cdp -o nospace -o nosort cdp

# cd to project root
cdpr() {
    local project=$(cpr)
    if [ ! -z "${project}" ]; then
        cdp "${project}"
    else
        echo "Not in a project"
    fi
}
