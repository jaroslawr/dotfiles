# GENERAL
#

# Define PROMPT_COMMAND as an array so following sections can add their own commands
PROMPT_COMMAND=()

# Source standard completions
source /usr/share/bash-completion/bash_completion

# Prevent Ctrl-S from freezing the terminal
stty -ixon

# FZF keybindings: cd with Alt-C, insert file path with Ctrl-T
source /usr/share/doc/fzf/examples/key-bindings.bash

# Set tmux title to simply "bash"
tmux_title() {
    echo -ne "\033]0;\a"
}
PROMPT_COMMAND+=("tmux_title")

# ENVIRONMENT
#

export EDITOR=nvim
export FZF_DEFAULT_OPTS="--tiebreak=index --no-mouse --no-bold \
    --layout=reverse --preview-window=down,border-top --margin 0,1 \
    --color 16,prompt:2,hl:2,hl+:2,fg+:3,pointer:3 \
    --bind shift-left:preview-page-up,shift-right:preview-page-down"
export FZF_TMUX=1
export LESS="--raw-control-chars --chop-long-lines --no-init"
export PATH="${HOME}/bin:${HOME}/go/bin:${PATH}"
export PROJECTS_DIR=~/Projects
export RIPGREP_CONFIG_PATH=~/.ripgreprc
export SSH_AUTH_SOCK="${XDG_RUNTIME_DIR}/.ssh-agent.sock"

# HISTORY
#

# Huge history
HISTSIZE=100000
HISTFILESIZE=100000

# Append to history file instead of overwriting it
shopt -s histappend

# Save multi line commands literally, with newlines as entered
shopt -s lithist

# Write history before each priting of the prompt
PROMPT_COMMAND+=("history -a")

# PROMPT
#

# Color definitions
RED="$(tput setaf 1)"
GREEN="$(tput setaf 2)"
YELLOW="$(tput setaf 3)"
BLUE="$(tput setaf 4)"
PURPLE="$(tput setaf 5)"
GRAY="$(tput setaf 7)"
RESET="$(tput sgr0)"

# Set git-related variables for prompt
__update_git_status() {
    GIT_REPO=$(git rev-parse --git-dir 2>&1 >/dev/null && echo true || echo false)

    if [ "${GIT_REPO}" = true ]; then
        IFS=$'\t' read \
            GIT_PS1_BRANCH \
            GIT_PS1_STAGED \
            GIT_PS1_NONSTAGED \
            GIT_PS1_UNTRACKED \
            < <(git status --branch --porcelain=v2 | awk -f ~/bin/parse-git-status.awk)
    fi
}

# Update git status before displaying the prompt
PROMPT_COMMAND+=("__update_git_status")

# Print the git branch part of the prompt
__ps1_git_branch() {
    if [ "${GIT_REPO}" = true ]; then
        echo "${GIT_PS1_BRANCH}"
    fi
}

# Print the git status part of the prompt
__ps1_git_status() {
    if [ "${GIT_REPO}" = true ]; then
        local status=""
        status+=$([ "${GIT_PS1_STAGED}" -gt 0 ] && echo "+" || echo "")
        status+=$([ "${GIT_PS1_NONSTAGED}" -gt 0 ] && echo "*" || echo "")
        status+=$([ "${GIT_PS1_UNTRACKED}" -gt 0 ] && echo "?" || echo "")
        echo "${status}"
    fi
}

# Save the exit code of last command before displaying the prompt
__save_exit_code() {
    EXIT_CODE=$?
}
PROMPT_COMMAND+=("__save_exit_code")

# Print the prompt ">"
# green if last command succeeded, red if it failed
__ps1_prompt() {
    if [ "${EXIT_CODE}" -eq 0 ]; then
        echo "${GREEN}>${RESET}"
    else
        echo "${RED}>${RESET}"
    fi
}

# Prompt definition
PS1="\[${YELLOW}\]\w \[${PURPLE}\]\$(__ps1_git_branch)\$(__ps1_git_status)
\$(__ps1_prompt) "

# ALIASES
#

# cal with more readable output
cal() {
    ncal -M -b "$@"
}

# ls with more readable output
ls() {
    command ls \
        --color=auto \
        --group-directories-first \
        --literal \
        --time-style=long-iso \
        --human-readable \
        "$@"
}

# diff with colors and pager, unless running in a pipeline
diff() {
    if [[ -t 1 ]]; then
        command diff --color=always "$@" | less -FRS
    else
        command diff "$@"
    fi
}

# rg with colors and pager, unless running in a pipeline
rg() {
    if [[ -t 1 ]]; then
        command rg --color=always --line-number "$@" | less -FRS
    else
        command rg "$@"
    fi
}

# FUNCTIONS
#

# open notes
nt() {
    $EDITOR ~/Notes/notes.md
}

# FUNCTIONS - PROJECTS
#

# cd to project
cdp() {
    local project_dir="${PROJECTS_DIR}/$1"
    if [ -d "${project_dir}" ]; then
        cd "${project_dir}"
    else
        echo "Project does not exist"
    fi
}

_cdp() {
    if [ ${#COMP_WORDS[@]} -gt 2 ]; then
        return
    fi

    local query=${COMP_WORDS[1]}

    if [[ ! "${query}" =~ / ]]; then
        # Find matching project directories

        declare -a prefix_matches
        declare -a infix_matches

        while IFS=$'\n' read -r match; do
            if [[ "${match}" =~ ^${query} ]]; then
                prefix_matches+=("${match}")
            else
                infix_matches+=("${match}")
            fi
        done < <(__cdp_find_subdirs "${PROJECTS_DIR}" "*${query}*" -printf "%P\n")

        COMPREPLY=("${prefix_matches[@]}" "${infix_matches[@]}")
    else
        # Find matching subdirectories within a project directory

        # The completed part of the user input - until last slash
        local complete_dirname=$(echo "${query}" | sed -E 's/(.*)\/.*/\1/')
        
        # The part of the user input to complete - after last slash
        local partial_dirname=$(echo "${query}" | sed -E 's/.*\/(.*)/\1/')

        # Starting point for find
        local root="${PROJECTS_DIR}/${complete_dirname}"

        readarray -t COMPREPLY < <(__cdp_find_subdirs "${root}" "${partial_dirname}*" -printf "${complete_dirname}/%P\n")
    fi
}

__cdp_find_subdirs() {
    # "dir" is lexicographically before "dir-xyz", but "dir/" is lexicographically after "dir-xyz/",
    # so sort first and only then add the trailing slash
    find "$1" -mindepth 1 -maxdepth 1 -not -path '*/.*' -type d -name "$2" "${@:3}" | \
        LC_ALL=C sort | sed 's/$/\//'
}

complete -F _cdp -o nospace -o nosort cdp

# cd to project root
cdpr() {
    local cwd=$(pwd)
    if [[ "${cwd}" =~ ^${PROJECTS_DIR}/.+$ ]]; then
        local project=$(echo "${cwd}" | cut -c "$((${#PROJECTS_DIR}+1))-" | cut -d/ -f2)
        cd "${PROJECTS_DIR}/${project}"
    else
        echo "Not in a project"
    fi
}

# FUNCTIONS - DIRECTORY TREES
#

# directory tree - with pager, unless running in a pipeline
t() {
    if [[ -t 1 ]]; then
        command rl "$@" | less -FRS
    else
        command rl "$@"
    fi
}

# directory tree - edit in vim
vt() {
    command rl "$@" | $EDITOR \
        -c ":lua require('filelist').load()" \
        -c ":bdelete!"
}

# FUNCTIONS - GIT
#

# git log browser
lg() {
    declare -a args
    declare -a paths

    while [ $# -gt 0 ]; do
        args+=("$1")
        shift

        if [ "$1" == "--" ]; then
            while [ $# -gt 0 ]; do
                paths+=("$1")
                shift
            done
        fi
    done

    if [ ${#paths[@]} -eq 0 ]; then
        paths=(".")
    fi

    local paths_expanded=$(printf "%q " "${paths[@]}")

    git lg --color=always "${args[@]}" -- "${paths[@]}" | \
        fzf \
        --ansi \
        --preview="git show --color=always {1} -- ${paths_expanded}" \
        --bind="ctrl-m:execute:(git show --color=always {1} -- ${paths_expanded} | less -CRX)"
}

